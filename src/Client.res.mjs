// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Urql from "urql";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Wonka from "wonka";
import * as Core from "@urql/core";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Types$ReScriptUrql from "./Types.res.mjs";

function unwrapFetchOptions(fetchOptions) {
  if (fetchOptions !== undefined) {
    return fetchOptions._0;
  }
  
}

function unwrapFetchImpl($$fetch) {
  if ($$fetch !== undefined) {
    return $$fetch._0;
  }
  
}

function subscriptionExchange(forwardSubscription, enableAllOperations, param) {
  return Urql.subscriptionExchange({
              forwardSubscription: forwardSubscription,
              enableAllOperations: enableAllOperations
            });
}

function makePersistedFetchExchangeOptions(preferGetForPersistedQueries, generateHash, param) {
  return {
          preferGetForPersistedQueries: preferGetForPersistedQueries,
          generateHash: generateHash
        };
}

function makeRequestPolicyExchangeOptions(shouldUpgrade, ttl, param) {
  return {
          shouldUpgrade: shouldUpgrade,
          ttl: ttl
        };
}

function makeRetryExchangeOptions(initialDelayMs, maxDelayMs, randomDelay, maxNumberAttempts, retryIf, param) {
  return {
          initialDelayMs: initialDelayMs,
          maxDelayMs: maxDelayMs,
          randomDelay: randomDelay,
          maxNumberAttempts: maxNumberAttempts,
          retryIf: retryIf
        };
}

var Exchanges = {
  subscriptionExchange: subscriptionExchange,
  makePersistedFetchExchangeOptions: makePersistedFetchExchangeOptions,
  makeRequestPolicyExchangeOptions: makeRequestPolicyExchangeOptions,
  makeRetryExchangeOptions: makeRetryExchangeOptions
};

function make(url, fetchOptions, $$fetch, exchangesOpt, suspenseOpt, requestPolicyOpt, preferGetMethodOpt, maskTypenameOpt, param) {
  var exchanges = exchangesOpt !== undefined ? exchangesOpt : Core.defaultExchanges;
  var suspense = suspenseOpt !== undefined ? suspenseOpt : false;
  var requestPolicy = requestPolicyOpt !== undefined ? requestPolicyOpt : "cache-first";
  var preferGetMethod = preferGetMethodOpt !== undefined ? preferGetMethodOpt : false;
  var maskTypename = maskTypenameOpt !== undefined ? maskTypenameOpt : false;
  return new Core.Client({
              url: url,
              fetchOptions: unwrapFetchOptions(fetchOptions),
              exchanges: exchanges,
              suspense: suspense,
              fetch: unwrapFetchImpl($$fetch),
              requestPolicy: Types$ReScriptUrql.requestPolicyToJs(requestPolicy),
              preferGetMethod: preferGetMethod,
              maskTypename: maskTypename
            });
}

function executeQuery(client, Query, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables) {
  var req = Urql.createRequest(Query.query, Curry._1(Query.variablesToJson, Curry._1(Query.serializeVariables, variables)));
  var tmp = {};
  if (additionalTypenames !== undefined) {
    tmp.additionalTypenames = Caml_option.valFromOption(additionalTypenames);
  }
  if ($$fetch !== undefined) {
    tmp.fetch = Caml_option.valFromOption($$fetch);
  }
  if (fetchOptions !== undefined) {
    tmp.fetchOptions = Caml_option.valFromOption(fetchOptions);
  }
  var tmp$1 = Belt_Option.map(requestPolicy, Types$ReScriptUrql.requestPolicyToJs);
  if (tmp$1 !== undefined) {
    tmp.requestPolicy = Caml_option.valFromOption(tmp$1);
  }
  if (url !== undefined) {
    tmp.url = Caml_option.valFromOption(url);
  }
  if (meta !== undefined) {
    tmp.meta = Caml_option.valFromOption(meta);
  }
  if (suspense !== undefined) {
    tmp.suspense = Caml_option.valFromOption(suspense);
  }
  if (preferGetMethod !== undefined) {
    tmp.preferGetMethod = Caml_option.valFromOption(preferGetMethod);
  }
  var optsJs = tmp;
  return Curry._1(Wonka.map(function (response) {
                  return Types$ReScriptUrql.operationResultToReScript(response, Query.parse);
                }), client.executeQuery(req, optsJs));
}

function executeMutation(client, Mutation, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables) {
  var req = Urql.createRequest(Mutation.query, Curry._1(Mutation.variablesToJson, Curry._1(Mutation.serializeVariables, variables)));
  var tmp = {};
  if (additionalTypenames !== undefined) {
    tmp.additionalTypenames = Caml_option.valFromOption(additionalTypenames);
  }
  if ($$fetch !== undefined) {
    tmp.fetch = Caml_option.valFromOption($$fetch);
  }
  if (fetchOptions !== undefined) {
    tmp.fetchOptions = Caml_option.valFromOption(fetchOptions);
  }
  var tmp$1 = Belt_Option.map(requestPolicy, Types$ReScriptUrql.requestPolicyToJs);
  if (tmp$1 !== undefined) {
    tmp.requestPolicy = Caml_option.valFromOption(tmp$1);
  }
  if (url !== undefined) {
    tmp.url = Caml_option.valFromOption(url);
  }
  if (meta !== undefined) {
    tmp.meta = Caml_option.valFromOption(meta);
  }
  if (suspense !== undefined) {
    tmp.suspense = Caml_option.valFromOption(suspense);
  }
  if (preferGetMethod !== undefined) {
    tmp.preferGetMethod = Caml_option.valFromOption(preferGetMethod);
  }
  var optsJs = tmp;
  return Curry._1(Wonka.map(function (response) {
                  return Types$ReScriptUrql.operationResultToReScript(response, Mutation.parse);
                }), client.executeMutation(req, optsJs));
}

function executeSubscription(client, Subscription, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables) {
  var req = Urql.createRequest(Subscription.query, Curry._1(Subscription.variablesToJson, Curry._1(Subscription.serializeVariables, variables)));
  var tmp = {};
  if (additionalTypenames !== undefined) {
    tmp.additionalTypenames = Caml_option.valFromOption(additionalTypenames);
  }
  if ($$fetch !== undefined) {
    tmp.fetch = Caml_option.valFromOption($$fetch);
  }
  if (fetchOptions !== undefined) {
    tmp.fetchOptions = Caml_option.valFromOption(fetchOptions);
  }
  var tmp$1 = Belt_Option.map(requestPolicy, Types$ReScriptUrql.requestPolicyToJs);
  if (tmp$1 !== undefined) {
    tmp.requestPolicy = Caml_option.valFromOption(tmp$1);
  }
  if (url !== undefined) {
    tmp.url = Caml_option.valFromOption(url);
  }
  if (meta !== undefined) {
    tmp.meta = Caml_option.valFromOption(meta);
  }
  if (suspense !== undefined) {
    tmp.suspense = Caml_option.valFromOption(suspense);
  }
  if (preferGetMethod !== undefined) {
    tmp.preferGetMethod = Caml_option.valFromOption(preferGetMethod);
  }
  var optsJs = tmp;
  return Curry._1(Wonka.map(function (response) {
                  return Types$ReScriptUrql.operationResultToReScript(response, Subscription.parse);
                }), client.executeSubscription(req, optsJs));
}

function query(client, query$1, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables) {
  return Wonka.toPromise(Curry._1(Wonka.take(1), executeQuery(client, query$1, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables)));
}

function mutation(client, mutation$1, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables) {
  return Wonka.toPromise(Curry._1(Wonka.take(1), executeMutation(client, mutation$1, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables)));
}

function readQuery(client, query, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables) {
  var result = {
    contents: undefined
  };
  var subscription = Curry._1(Wonka.subscribe(function (data) {
            result.contents = data;
          }), executeQuery(client, query, additionalTypenames, fetchOptions, $$fetch, requestPolicy, url, meta, suspense, preferGetMethod, variables));
  Curry._1(subscription.unsubscribe, undefined);
  return result.contents;
}

var subscription = executeSubscription;

export {
  Exchanges ,
  make ,
  executeQuery ,
  executeMutation ,
  executeSubscription ,
  query ,
  mutation ,
  subscription ,
  readQuery ,
}
/* urql Not a pure module */
