// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core from "@urql/core";
import * as Jest$ReScriptUrql from "../src/Jest.res.mjs";
import * as Client$ReScriptUrql from "../src/Client.res.mjs";

Jest$ReScriptUrql.describe("Client", (function (param) {
        Jest$ReScriptUrql.describe("Client with only a url provided", (function (param) {
                var client = Client$ReScriptUrql.make("https://localhost:3000", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
                Jest$ReScriptUrql.test("should instantiate a client instance", (function (param) {
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
                Jest$ReScriptUrql.test("should expose an executeQuery method", (function (param) {
                        return Jest$ReScriptUrql.ExpectJs.toBeTruthy(Jest$ReScriptUrql.ExpectJs.expect(Client$ReScriptUrql.executeQuery));
                      }));
                Jest$ReScriptUrql.test("should expose an executeMutation method", (function (param) {
                        return Jest$ReScriptUrql.ExpectJs.toBeTruthy(Jest$ReScriptUrql.ExpectJs.expect(Client$ReScriptUrql.executeMutation));
                      }));
                Jest$ReScriptUrql.test("should expose an executeSubscription method", (function (param) {
                        return Jest$ReScriptUrql.ExpectJs.toBeTruthy(Jest$ReScriptUrql.ExpectJs.expect(Client$ReScriptUrql.executeSubscription));
                      }));
              }));
        Jest$ReScriptUrql.describe("Client with fetchOptions provided", (function (param) {
                var fetchOptions_method = "POST";
                var fetchOptions_headers = {
                  "Content-Type": "application/json"
                };
                var fetchOptions = {
                  method: fetchOptions_method,
                  headers: fetchOptions_headers
                };
                Jest$ReScriptUrql.test("should instantiate a client instance with fetchOptions provided as FetchOpts", (function (param) {
                        var client = Client$ReScriptUrql.make("https://localhost:3000", {
                              TAG: "FetchOpts",
                              _0: fetchOptions
                            }, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
                Jest$ReScriptUrql.test("should instantiate a client instance with fetchOptions provided as FetchFn", (function (param) {
                        var client = Client$ReScriptUrql.make("https://localhost:3000", {
                              TAG: "FetchFn",
                              _0: (function (param) {
                                  return fetchOptions;
                                })
                            }, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
              }));
        Jest$ReScriptUrql.describe("Client with default requestPolicy", (function (param) {
                Jest$ReScriptUrql.test("should accept a default requestPolicy", (function (param) {
                        var client = Client$ReScriptUrql.make("https://localhost:3000", undefined, undefined, undefined, undefined, "cache-and-network", undefined, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
              }));
        Jest$ReScriptUrql.describe("Client with suspense flag", (function (param) {
                Jest$ReScriptUrql.test("should accept a suspense flag to enable experimental SSR mode", (function (param) {
                        var client = Client$ReScriptUrql.make("https://localhost:3000", undefined, undefined, undefined, true, undefined, undefined, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
              }));
        Jest$ReScriptUrql.describe("Client with exchanges provided", (function (param) {
                Jest$ReScriptUrql.test("should instantiate a client with exchanges", (function (param) {
                        var client = Client$ReScriptUrql.make("https://localhost:3000", undefined, undefined, [Core.debugExchange], undefined, undefined, undefined, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
                Jest$ReScriptUrql.test("should allow a user to compose exchanges into a single exchange", (function (param) {
                        return Jest$ReScriptUrql.Expect.toThrow(Jest$ReScriptUrql.Expect.not_(Jest$ReScriptUrql.Expect.expect(function (param) {
                                            return Core.composeExchanges([
                                                        Core.debugExchange,
                                                        Core.cacheExchange,
                                                        Core.fetchExchange
                                                      ]);
                                          })));
                      }));
                Jest$ReScriptUrql.test("should return a single exchange from compose exchanges", (function (param) {
                        return Jest$ReScriptUrql.Expect.toHaveLength(Jest$ReScriptUrql.Expect.expect([Core.composeExchanges([
                                              Core.debugExchange,
                                              Core.cacheExchange,
                                              Core.fetchExchange
                                            ])]), 1);
                      }));
              }));
        Jest$ReScriptUrql.describe("ssrExchange", (function (param) {
                Jest$ReScriptUrql.test("should exist and be callable", (function (param) {
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(Core.ssrExchange(undefined)));
                      }));
                Jest$ReScriptUrql.test("should accept an initialState for passing data extracted during SSR prepass", (function (param) {
                        var json = {};
                        json["key"] = 1;
                        json["key2"] = 2;
                        var serializedResult_data = json;
                        var serializedResult = {
                          data: serializedResult_data,
                          error: undefined
                        };
                        var initialState = {};
                        initialState["query"] = serializedResult;
                        var ssrExchangeParams_isClient = false;
                        var ssrExchangeParams_initialState = initialState;
                        var ssrExchangeParams = {
                          isClient: ssrExchangeParams_isClient,
                          initialState: ssrExchangeParams_initialState
                        };
                        return Jest$ReScriptUrql.Expect.toThrow(Jest$ReScriptUrql.Expect.not_(Jest$ReScriptUrql.Expect.expect(function (param) {
                                            return Core.ssrExchange(ssrExchangeParams);
                                          })));
                      }));
                Jest$ReScriptUrql.test("should expose an extractData method for extracting server-side rendered data", (function (param) {
                        var ssrCache = Core.ssrExchange(undefined);
                        return Jest$ReScriptUrql.Expect.toThrow(Jest$ReScriptUrql.Expect.not_(Jest$ReScriptUrql.Expect.expect(function (param) {
                                            return ssrCache.extractData();
                                          })));
                      }));
                Jest$ReScriptUrql.test("should expose a restoreData method for rehydrating data fetched server-side on the client", (function (param) {
                        var json = {};
                        json["key"] = 1;
                        json["key2"] = 2;
                        var ssrCache = Core.ssrExchange(undefined);
                        return Jest$ReScriptUrql.Expect.toThrow(Jest$ReScriptUrql.Expect.not_(Jest$ReScriptUrql.Expect.expect(function (param) {
                                            return ssrCache.restoreData(json);
                                          })));
                      }));
              }));
        Jest$ReScriptUrql.describe("with custom fetch implementation", (function (param) {
                Jest$ReScriptUrql.test("should accept a custom fetch implementation", (function (param) {
                        var fetcher = function (url) {
                          return fetch(url, {});
                        };
                        var client = Client$ReScriptUrql.make("http://localhost:3000", undefined, {
                              TAG: "FetchWithUrl",
                              _0: fetcher
                            }, undefined, undefined, undefined, undefined, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
                Jest$ReScriptUrql.test("should work with a fetcher using Fetch.Request.t", (function (param) {
                        var fetcher = function (request) {
                          var match = request.destination;
                          if (match === "audio") {
                            return fetch(new Request("/audio/graphql", {}));
                          } else {
                            return fetch(new Request("/graphql", {}));
                          }
                        };
                        var client = Client$ReScriptUrql.make("http://localhost:3000", undefined, {
                              TAG: "FetchWithRequest",
                              _0: fetcher
                            }, undefined, undefined, undefined, undefined, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
              }));
        Jest$ReScriptUrql.describe("with preferGetMethod", (function (param) {
                Jest$ReScriptUrql.test("respects the preferGetMethod flag", (function (param) {
                        var client = Client$ReScriptUrql.make("https://localhost:3000", undefined, undefined, undefined, undefined, undefined, true, undefined, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
              }));
        Jest$ReScriptUrql.describe("with maskTypename", (function (param) {
                Jest$ReScriptUrql.test("respects the maskTypename flag", (function (param) {
                        var client = Client$ReScriptUrql.make("https://localhost:3000", undefined, undefined, undefined, undefined, undefined, undefined, true, undefined);
                        return Jest$ReScriptUrql.Expect.toMatchSnapshot(Jest$ReScriptUrql.Expect.expect(client));
                      }));
              }));
        Jest$ReScriptUrql.describe("Ecosystem exchanges", (function (param) {
                Jest$ReScriptUrql.describe("persistedFetchExchange", (function (param) {
                        Jest$ReScriptUrql.test("should return None for all persistedFetchExchange options if unspecified", (function (param) {
                                var persistedFetchExchangeOptions = Client$ReScriptUrql.Exchanges.makePersistedFetchExchangeOptions(undefined, undefined, undefined);
                                return Jest$ReScriptUrql.Expect.toEqual(Jest$ReScriptUrql.Expect.expect(persistedFetchExchangeOptions), {
                                            preferGetForPersistedQueries: undefined,
                                            generateHash: undefined
                                          });
                              }));
                        Jest$ReScriptUrql.test("should apply any specified options to the persistedFetchExchange", (function (param) {
                                var hashFn = function (query, param) {
                                  return Promise.resolve(query.normalize());
                                };
                                var persistedFetchExchangeOptions = Client$ReScriptUrql.Exchanges.makePersistedFetchExchangeOptions(true, hashFn, undefined);
                                return Jest$ReScriptUrql.Expect.toEqual(Jest$ReScriptUrql.Expect.expect(persistedFetchExchangeOptions), {
                                            preferGetForPersistedQueries: true,
                                            generateHash: hashFn
                                          });
                              }));
                      }));
                Jest$ReScriptUrql.describe("requestPolicyExchange", (function (param) {
                        Jest$ReScriptUrql.test("should return None for all requestPolicyExchange options if unspecified", (function (param) {
                                var requestPolicyExchangeOptions = Client$ReScriptUrql.Exchanges.makeRequestPolicyExchangeOptions(undefined, undefined, undefined);
                                return Jest$ReScriptUrql.Expect.toEqual(Jest$ReScriptUrql.Expect.expect(requestPolicyExchangeOptions), {
                                            shouldUpgrade: undefined,
                                            ttl: undefined
                                          });
                              }));
                        Jest$ReScriptUrql.test("should apply any specified options to the requestPolicyExchange", (function (param) {
                                var shouldUpgrade = function (operation) {
                                  return operation.context.requestPolicy !== "cache-only";
                                };
                                var requestPolicyExchangeOptions = Client$ReScriptUrql.Exchanges.makeRequestPolicyExchangeOptions(shouldUpgrade, 2000, undefined);
                                return Jest$ReScriptUrql.Expect.toEqual(Jest$ReScriptUrql.Expect.expect(requestPolicyExchangeOptions), {
                                            shouldUpgrade: shouldUpgrade,
                                            ttl: 2000
                                          });
                              }));
                      }));
                Jest$ReScriptUrql.describe("retryExchange", (function (param) {
                        Jest$ReScriptUrql.test("should apply the default retryExchange options from urql if none are applied", (function (param) {
                                var retryExchangeOptions = Client$ReScriptUrql.Exchanges.makeRetryExchangeOptions(undefined, undefined, undefined, undefined, undefined, undefined);
                                return Jest$ReScriptUrql.Expect.toEqual(Jest$ReScriptUrql.Expect.expect(retryExchangeOptions), {
                                            initialDelayMs: undefined,
                                            maxDelayMs: undefined,
                                            randomDelay: undefined,
                                            maxNumberAttempts: undefined,
                                            retryIf: undefined
                                          });
                              }));
                        Jest$ReScriptUrql.test("should apply any specified options to the retryExchange", (function (param) {
                                var retryExchangeOptions = Client$ReScriptUrql.Exchanges.makeRetryExchangeOptions(200, undefined, false, undefined, undefined, undefined);
                                return Jest$ReScriptUrql.Expect.toEqual(Jest$ReScriptUrql.Expect.expect(retryExchangeOptions), {
                                            initialDelayMs: 200,
                                            maxDelayMs: undefined,
                                            randomDelay: false,
                                            maxNumberAttempts: undefined,
                                            retryIf: undefined
                                          });
                              }));
                      }));
              }));
      }));

var it = Jest$ReScriptUrql.test;

export {
  it ,
}
/*  Not a pure module */
